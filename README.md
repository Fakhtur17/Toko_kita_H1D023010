
Aplikasi Tokokita adalah sebuah aplikasi mobile berbasis Flutter yang dirancang dengan struktur modular serta alur navigasi yang berurutan mulai dari proses autentikasi hingga pengelolaan data produk. Pengembangan aplikasi ini dimulai dari pendefinisian beberapa model data yang menjadi fondasi utama dalam pengolahan informasi, yaitu model Login, Produk, dan Registrasi. Setiap model disusun menggunakan pendekatan object mapping, di mana data yang berasal dari JSON server dapat dikonversi secara otomatis menjadi objek Dart dengan struktur yang lebih mudah diakses. Model Login, misalnya, menerima data berupa kode status, token autentikasi, ID pengguna, dan email pengguna, yang semuanya dikelola melalui factory Login.fromJson(). Model ini memastikan bahwa proses autentikasi dapat berlangsung dengan standar yang jelas dan memisahkan antara login berhasil dan gagal. Sementara itu, model Produk berfungsi sebagai representasi setiap barang yang ditampilkan dalam aplikasi, mencakup id, kode produk, nama produk, dan harga. Model ini digunakan di seluruh modul aplikasi—baik dalam daftar produk, detail produk, maupun form tambah dan edit produk. Adapun model Registrasi merupakan struktur data untuk menampung hasil pendaftaran pengguna baru.

Alur aplikasi dimulai dari file main.dart, yang berfungsi sebagai pintu masuk utama program. Pada file ini, aplikasi menginisialisasi widget MyApp, kemudian mengatur bahwa halaman pertama yang harus ditampilkan adalah LoginPage. Dengan demikian, setiap kali aplikasi dibuka, pengguna selalu diarahkan menuju halaman login terlebih dahulu. Ini juga menjadi dasar bahwa aplikasi Tokokita menerapkan pola authentication-gated content, yaitu semua konten berada di balik proses login. Meskipun Flutter menyediakan halaman bawaan berupa MyHomePage, halaman tersebut tidak digunakan dalam aplikasi ini, karena seluruh navigasi diarahkan melalui LoginPage.

Pada halaman LoginPage, aplikasi menyajikan antarmuka modern yang dibangun dengan pendekatan visual card, ikon aplikasi, serta tata letak form yang bersih. Pengguna diminta memasukkan email dan password. Sistem validasi diterapkan secara ketat, misalnya email wajib berformat benar dan password minimal empat karakter. Validasi dilakukan melalui mekanisme Form dan GlobalKey<FormState> yang memastikan bahwa seluruh data memenuhi syarat sebelum aplikasi mengizinkan pengguna melanjutkan. Jika input sudah sesuai, aplikasi melakukan navigasi menuju ProdukPage dengan menggunakan Navigator.pushReplacement, yang berarti halaman login dihapus dari navigation stack, sehingga pengguna tidak dapat kembali ke halaman login hanya dengan menekan tombol back. Hal ini menciptakan alur login yang aman dan terstruktur. Tidak hanya itu, LoginPage juga menyediakan tautan menuju halaman RegistrasiPage, sebagai alternatif bagi pengguna baru.

Proses Login

<img width="1574" height="893" alt="image" src="https://github.com/user-attachments/assets/58743622-f988-4b5c-bab6-308448d90344" />

<img width="1572" height="876" alt="image" src="https://github.com/user-attachments/assets/b678a653-9e8b-4098-9e2c-575a1adc0ee2" />



Halaman login diimplementasikan pada kelas LoginPage yang merupakan sebuah StatefulWidget. Ketika aplikasi dibuka, pengguna akan langsung diarahkan ke halaman ini. Tampilan utamanya terdiri dari sebuah AppBar dengan judul “Login Ramadhan Fakhtur Rakhman”, lalu di bagian isi terdapat form yang dibungkus Form dengan sebuah GlobalKey<FormState> untuk menangani proses validasi. Di dalam form ini terdapat dua buah TextFormField, masing-masing untuk input email dan password. Field email menggunakan keyboardType: TextInputType.emailAddress agar keyboard menyesuaikan, dan memiliki validator yang memastikan bahwa nilai tidak boleh kosong dan harus mengandung karakter @ sebagai validasi sederhana format email. Field password dibuat dengan properti obscureText yang dikontrol oleh variabel _obscure, sehingga pengguna bisa menampilkan atau menyembunyikan karakter password melalui ikon mata pada suffixIcon. Validator pada field password memastikan bahwa password tidak boleh kosong dan minimal terdiri dari empat karakter, sehingga pengguna tidak bisa mengirimkan password yang terlalu pendek.

Di bawah kedua field tersebut terdapat sebuah tombol ElevatedButton sebagai tombol “Login”. Tombol ini dibungkus dalam SizedBox agar lebarnya memenuhi layar dan tinggi konsisten. Ketika tombol ditekan, aplikasi terlebih dahulu memanggil validate() pada _formKey.currentState. Jika salah satu field tidak valid, pesan kesalahan akan muncul di bawah field yang bermasalah dan proses berhenti. Jika semua input valid dan kondisi _isLoading bernilai false, maka fungsi _submit() dipanggil. Variabel _isLoading digunakan sebagai indikator proses asynchronous; ketika bernilai true, tombol akan menampilkan widget CircularProgressIndicator berwarna putih menggantikan teks “Login”, sehingga pengguna tahu bahwa aplikasi sedang memproses permintaan dan tidak bisa menekan tombol berkali-kali. Setelah proses selesai, _isLoading dikembalikan ke false supaya tombol kembali normal.

Fungsi _submit() berisi logika utama login. Pertama, state diubah dengan setState agar _isLoading bernilai true. Kemudian aplikasi memanggil LoginBloc.login, yaitu fungsi statis yang akan melakukan request ke REST API menggunakan helper Api. Fungsi ini mengirimkan email dan password yang diambil dari controller _emailController dan _passwordController ke endpoint yang didefinisikan di ApiUrl.login. Response dari server diterima dalam bentuk JSON, lalu diubah menjadi objek Login oleh Login.fromJson. Di dalam factory ini, field status dipastikan menjadi nilai boolean yang konsisten dengan cara memeriksa apakah nilai obj['status'] bernilai true, 1, atau string "1". Jika login berhasil, objek Login akan berisi kode status, token autentikasi, informasi userID, dan email pengguna.

Setelah promise pada LoginBloc.login selesai, callback then di _submit() akan dijalankan. Aplikasi terlebih dahulu mengubah _isLoading menjadi false agar tampilan kembali normal. Kemudian dilakukan pengecekan terhadap value.status. Jika status == true, berarti login berhasil. Dalam kondisi ini, token dan userID yang didapatkan dari server disimpan secara lokal menggunakan helper UserInfo, melalui pemanggilan UserInfo().setToken() dan UserInfo().setUserID(). Penyimpanan ini penting sebagai dasar otentikasi untuk request API selanjutnya, karena helper Api akan otomatis menyertakan header Authorization: Bearer <token> pada setiap request. Setelah data login disimpan, aplikasi melakukan navigasi ke halaman utama produk (ProdukPage) menggunakan Navigator.pushReplacement. Penggunaan pushReplacement memastikan bahwa halaman login dihapus dari stack sehingga pengguna tidak bisa kembali ke login dengan tombol back setelah berhasil masuk. Jika login gagal, baik karena status dari server bernilai false maupun terjadi error jaringan, aplikasi akan menampilkan WarningDialog dengan pesan “Login gagal, silahkan coba lagi”. Dialog ini ditampilkan menggunakan showDialog dan akan menutup dirinya sendiri ketika pengguna menekan tombol OK.

Di bagian bawah card login juga terdapat menu registrasi berupa teks “Belum punya akun? Registrasi”. Teks “Registrasi” dibungkus dengan InkWell, sehingga ketika disentuh, aplikasi akan membuka halaman RegistrasiPage menggunakan Navigator.push. Dengan cara ini, alur login–registrasi saling terhubung: dari login pengguna dapat menuju registrasi jika belum memiliki akun, dan setelah registrasi berhasil, pengguna diharapkan kembali ke login untuk menggunakan akun barunya.

Halaman RegistrasiPage dirancang untuk menangani pembuatan akun baru oleh pengguna. Pada halaman ini terdapat form yang lebih kompleks karena mencakup input nama lengkap, email, password, dan konfirmasi password. Validasi dilakukan secara berlapis: nama minimal tiga karakter, email harus valid, password minimal enam karakter, dan konfirmasi password harus sama dengan password sebelumnya. Ketika seluruh input telah sesuai, aplikasi menampilkan pesan snackbar “Registrasi berhasil!” dan mengarahkan pengguna kembali ke halaman login menggunakan Navigator.pop(context). Dengan pendekatan ini, aplikasi memastikan bahwa proses registrasi berjalan aman, valid, dan sesuai standar pengumpulan data pengguna.

Proses Registrasi

<img width="1583" height="877" alt="image" src="https://github.com/user-attachments/assets/5d5cd449-a198-4cca-8210-8bdcb5ee8675" />

<img width="1575" height="885" alt="image" src="https://github.com/user-attachments/assets/a9513d63-28dd-4283-9cd8-53b043475fbf" />


Halaman registrasi diimplementasikan pada kelas RegistrasiPage yang juga merupakan StatefulWidget. Secara tampilan, halaman ini memiliki AppBar berwarna biru dengan judul “Registrasi Ramadhan Fakhtur Rakhman”, lalu di bagian isi terdapat header berbentuk CircleAvatar dengan ikon orang dan teks “Buat Akun Tokokita”, sehingga secara visual konsisten dengan tema aplikasi. Di bawah header terdapat sebuah card putih yang berisi form registrasi. Form tersebut juga menggunakan GlobalKey<FormState> yang sama seperti di halaman login untuk memudahkan proses validasi. Di dalam form, terdapat empat buah TextFormField, yaitu untuk nama lengkap, email, password, dan konfirmasi password. Tiap field menggunakan dekorasi konsisten yang dihasilkan oleh fungsi _inputDecoration, sehingga semua input memiliki border melengkung, ikon di sisi kiri (prefixIcon), dan gaya tampilan yang seragam.

Field nama menggunakan validator yang memastikan bahwa pengguna wajib mengisi nama dan panjang nama minimal tiga karakter, sehingga input tidak kosong dan cukup informatif. Field email menggunakan keyboardType: TextInputType.emailAddress dengan validator sederhana yang memastikan email tidak kosong dan mengandung karakter @. Field password dan konfirmasi password keduanya menggunakan obscureText yang dikontrol oleh variabel _obscurePass dan _obscureConfirm, sehingga pengguna bisa menampilkan atau menyembunyikan isi password melalui tombol ikon mata pada suffixIcon. Validator field password memastikan password tidak kosong dan minimal terdiri dari enam karakter. Sementara itu, validator pada field konfirmasi password memastikan bahwa input tidak kosong dan harus sama persis dengan isi _passwordController.text. Jika keduanya berbeda, pesan kesalahan “Konfirmasi password tidak sama” akan ditampilkan, mencegah pengguna mengirimkan password yang salah ketik.

Tombol “Registrasi” berada di bagian bawah card dan ditampilkan menggunakan ElevatedButton dengan lebar penuh dan tinggi tetap. Ketika tombol ditekan, aplikasi memanggil validate() pada _formKey.currentState. Jika salah satu input tidak valid, proses berhenti dan pesan error tampil di bawah field yang bersangkutan. Jika semua valid dan variabel _isLoading bernilai false, maka fungsi _submit() dipanggil. Sama seperti pada halaman login, _isLoading digunakan untuk menampilkan atau menyembunyikan indikator loading di dalam tombol. Saat registrasi sedang diproses, teks “Registrasi” di dalam tombol digantikan oleh CircularProgressIndicator berwarna putih, sehingga pengguna menyadari bahwa form sedang dikirim dan tidak diizinkan menekan tombol lagi sampai proses selesai.

Fungsi _submit() pada RegistrasiPage berisi logika utama proses registrasi pengguna. Pertama, save() dipanggil pada _formKey.currentState untuk memastikan nilai-nilai form sudah terikat, kemudian setState mengubah _isLoading menjadi true. Setelah itu, fungsi memanggil RegistrasiBloc.registrasi, yang akan melakukan request POST ke endpoint ApiUrl.registrasi menggunakan helper Api. Data yang dikirim berupa map dengan key nama, email, dan password, diambil dari masing-masing controller. Response dari server dibaca sebagai JSON, lalu dikonversi menjadi objek Registrasi melalui Registrasi.fromJson. Di dalam factory ini, nilai status kembali dinormalisasi menjadi boolean dengan memeriksa apakah field obj['status'] bernilai true, 1, atau string "1". Field data biasanya berisi pesan dari server, misalnya pesan sukses atau error.

Setelah request selesai, callback then dijalankan, dan _isLoading diset kembali ke false agar tombol registrasi kembali ke keadaan normal. Jika value.status == true, berarti registrasi berhasil. Dalam kasus ini, aplikasi menampilkan SuccessDialog dengan teks deskripsi yang diambil dari value.data, atau pesan default “Registrasi berhasil, silahkan login” jika field tersebut kosong. SuccessDialog ditampilkan menggunakan showDialog dengan barrierDismissible: false, sehingga pengguna hanya bisa menutup dialog melalui tombol OK. Di dalam konstruktor SuccessDialog, juga dikirimkan sebuah callback okClick. Callback ini berisi pemanggilan Navigator.pop(context), yang bertugas menutup halaman registrasi dan mengembalikan pengguna ke halaman login. Di sisi lain, implementasi SuccessDialog sendiri akan menutup dialog ketika tombol OK ditekan dengan memanggil Navigator.of(context).pop() dan kemudian menjalankan okClick jika tidak null. Dengan demikian, alur lengkapnya adalah: dialog ditutup terlebih dahulu, lalu callback dari halaman registrasi dipanggil untuk mem-pop halaman registrasi dari navigator, sehingga pengguna otomatis kembali ke form login setelah mengakui pesan “SUKSES”.

Jika value.status bernilai false atau terjadi error lain, maka bukannya menampilkan SuccessDialog, aplikasi akan memunculkan WarningDialog dengan pesan kegagalan. Untuk error dari server, pesan diambil dari value.data jika tersedia, dengan fallback “Registrasi gagal, silahkan coba lagi”. Untuk error jaringan atau exception lain, blok onError di _submit() akan menampilkan WarningDialog dengan pesan umum bahwa registrasi gagal dan pengguna diminta mencoba kembali. Di bagian paling bawah card registrasi juga terdapat tombol teks “Sudah punya akun? Login” yang hanya memanggil Navigator.pop(context) ketika ditekan, sehingga pengguna bisa kembali ke halaman login tanpa melakukan registrasi jika merasa sudah memiliki akun.

Dengan alur tersebut, halaman login dan registrasi saling terhubung dengan jelas: pengguna yang belum memiliki akun bisa berpindah dari login ke registrasi, mengisi data yang divalidasi dengan benar, mengirimkannya ke server melalui Bloc, dan setelah registrasi sukses, kembali lagi ke halaman login dalam keadaan form siap digunakan untuk masuk ke dalam aplikasi menggunakan akun baru mereka.

Setelah login berhasil, pengguna diarahkan menuju halaman ProdukPage, yang merupakan pusat aktivitas aplikasi. Pada halaman ini pengguna dapat melihat daftar produk yang ditampilkan dalam bentuk kartu menggunakan widget ItemProduk. Daftar ini ditampilkan menggunakan ListView, sehingga pengguna dapat menggulir produk secara vertikal. Setiap produk memiliki atribut nama dan harga. Ketika pengguna mengetuk salah satu kartu produk, aplikasi akan menavigasikan pengguna menuju halaman ProdukDetail, yang menampilkan informasi lengkap mengenai produk tersebut, mencakup kode produk, nama produk, dan harga produk. Halaman ini juga menyediakan tombol EDIT dan DELETE. Tombol EDIT akan membuka halaman ProdukForm dalam mode edit, di mana data lama produk secara otomatis dimuat ke dalam form. Tombol DELETE saat ini belum memiliki logika penghapusan, namun disediakan sebagai placeholder untuk pengembangan lebih lanjut.
Halaman utama setelah login adalah ProdukPage, yang berfungsi sebagai daftar semua produk yang tersimpan di server. ProdukPage adalah StatefulWidget yang di dalam build-nya menggunakan sebuah Scaffold dengan AppBar berjudul “List Produk”, ikon tambah di bagian kanan atas, serta sebuah Drawer yang berisi menu logout. Bagian body menggunakan FutureBuilder yang memanggil ProdukBloc.getProduks(); fungsi ini melakukan request GET ke endpoint /produk, kemudian mengubah data JSON dari server menjadi list objek Produk. Selama data belum didapat, FutureBuilder akan menampilkan CircularProgressIndicator di tengah layar, dan jika sudah berhasil, data tersebut diteruskan ke widget ListProduk. Di dalam ListProduk, data list produk digambar menggunakan ListView.builder; setiap baris diwakili oleh widget ItemProduk yang menampilkan nama produk sebagai title dan harga produk sebagai subtitle. Seluruh baris produk dibungkus dengan GestureDetector, sehingga ketika salah satu item ditekan, aplikasi akan melakukan navigasi ke halaman ProdukDetail sambil mengirimkan objek Produk yang dipilih sebagai parameter.

Masih di ProdukPage, tombol tambah produk di AppBar memanfaatkan GestureDetector pada sebuah ikon Icons.add. Ketika ikon ini ditekan, aplikasi memanggil Navigator.push untuk membuka halaman ProdukForm tanpa membawa data produk apa pun. Mode ini menandakan bahwa pengguna sedang ingin menambahkan data baru. Sementara itu, pada sisi kiri layar terdapat Drawer dengan satu ListTile bertuliskan “Logout”. Ketika menu logout dipilih, fungsi LogoutBloc.logout() dipanggil untuk menghapus token dan informasi user (umumnya melalui kelas UserInfo dan SharedPreferences), kemudian Navigator.of(context).pushAndRemoveUntil digunakan untuk mengarahkan pengguna kembali ke LoginPage dan menghapus seluruh riwayat halaman sebelumnya dari stack, sehingga pengguna benar-benar keluar dari sesi aplikasinya.

Proses tambah dan ubah data produk dikendalikan oleh halaman ProdukForm, yang juga merupakan StatefulWidget. Halaman ini menerima parameter opsional berupa objek Produk; jika parameter ini berisi nilai (tidak null), berarti form sedang dibuka dalam mode edit, sedangkan jika null berarti form dipakai untuk menambah produk baru. Di dalam initState, fungsi isUpdate() dijalankan untuk menentukan mode form. Jika widget.produk tidak null, judul AppBar diubah menjadi “UBAH PRODUK”, teks tombol submit menjadi “UBAH”, dan ketiga TextEditingController diisi dengan nilai kode produk, nama produk, dan harga produk dari objek yang dikirim. Jika widget.produk null, judul dan label tombol diset ke “TAMBAH PRODUK” dan “SIMPAN”. Form ini menggunakan tiga buah TextFormField, masing-masing untuk kode produk, nama produk, dan harga. Ketiganya memiliki validator sederhana yang memastikan bahwa input tidak boleh kosong. Field harga juga menggunakan keyboardType: TextInputType.number supaya memudahkan pengguna memasukkan angka. Di bagian bawah form terdapat sebuah tombol OutlinedButton yang teksnya mengikuti variabel tombolSubmit; ketika tombol ini ditekan, form akan menjalankan _formKey.currentState!.validate(), dan jika semua input valid serta _isLoading bernilai false, form akan memutuskan apakah akan memanggil fungsi simpan() untuk menambah produk baru atau ubah() untuk memperbarui produk lama, bergantung pada apakah widget.produk null atau tidak.

Fungsi simpan() bertanggung jawab mengirim data produk baru ke server. Di awal fungsi, _isLoading diubah menjadi true agar aplikasi dapat menonaktifkan interaksi berulang dan, jika diinginkan, menampilkan indikator pemrosesan. Sebuah objek Produk baru dibuat dengan id: null, kemudian properti kodeProduk, namaProduk, dan hargaProduk diisi dari isi textbox yang dikontrol oleh _kodeProdukTextboxController, _namaProdukTextboxController, dan _hargaProdukTextboxController (yang dikonversi ke int menggunakan int.parse). Objek ini kemudian dikirim ke server melalui ProdukBloc.addProduk, yang di dalamnya memanggil helper Api().post ke endpoint ApiUrl.createProduk. Response dari server berupa JSON didekode, lalu field status dikonversi menjadi boolean dengan memperlakukan nilai true, 1, maupun string "1" sebagai keberhasilan. Jika hasilnya true, maka di dalam callback then, _isLoading diset kembali ke false dan Navigator.pushReplacement dipanggil untuk menutup halaman form dan menggantinya dengan ProdukPage terbaru, sehingga pengguna langsung melihat daftar produk yang sudah termasuk data baru. Jika server mengembalikan status false atau terjadi kesalahan, maka aplikasi menampilkan WarningDialog dengan pesan “Simpan gagal, silahkan coba lagi” atau “Terjadi kesalahan koneksi”, sesuai dengan apakah error berasal dari server atau dari exception jaringan yang ditangkap di catchError.

<img width="1569" height="891" alt="image" src="https://github.com/user-attachments/assets/b55ee293-9df4-40ea-a188-e915710dfc02" />

Logika untuk mengubah data produk lama diatur dalam fungsi ubah(), yang strukturnya mirip dengan simpan() tetapi menggunakan endpoint berbeda. Pertama _isLoading dibuat true, lalu dibuat objek Produk baru dengan id diambil dari widget.produk!.id, sehingga server tahu baris mana yang akan diperbarui. Properti kode, nama, dan harga diisi dari nilai yang baru dimasukkan pengguna di form. Fungsi ini kemudian memanggil ProdukBloc.updateProduk, yang melakukan request PUT ke URL yang dibentuk oleh ApiUrl.updateProduk(int.parse(produk.id!)). Body request dikirim dalam format JSON string (jsonEncode(body)) dan header Content-Type disetel menjadi application/json di dalam helper Api.put. Response server kembali dibaca dan nilai status dikonversi menjadi boolean dengan cara yang sama. Jika update berhasil, Navigator.pushReplacement digunakan lagi untuk membawa pengguna kembali ke ProdukPage sehingga ia langsung melihat daftar produk yang sudah diperbarui. Jika update gagal, aplikasi menampilkan WarningDialog dengan pesan “Ubah data gagal, silahkan coba lagi” atau pesan kesalahan koneksi jika terjadi exception.

Detail setiap produk ditampilkan di halaman ProdukDetail, yang menerima sebuah objek Produk melalui konstruktor. Di dalam build, halaman ini menampilkan informasi kode produk, nama produk, dan harga dalam bentuk teks yang dibesarkan, sehingga pengguna dapat dengan mudah mengidentifikasi item yang sedang dilihat. Di bawah informasi tersebut terdapat dua buah tombol OutlinedButton yang disusun dalam sebuah Row. Tombol pertama berlabel “EDIT”, yang ketika ditekan akan membuka kembali halaman ProdukForm namun kali ini dengan parameter produk diisi widget.produk. Dengan demikian, form akan masuk ke mode edit dan field-fieldnya terisi otomatis dengan data produk yang dipilih. Tombol kedua berlabel “DELETE”, yang memanggil fungsi confirmHapus(). Fungsi ini menampilkan sebuah AlertDialog yang menanyakan konfirmasi kepada pengguna, “Yakin ingin menghapus data ini?”. Jika pengguna memilih “Batal”, dialog hanya ditutup dengan Navigator.pop(context). Jika pengguna menekan tombol “Ya”, maka ProdukBloc.deleteProduk dipanggil dengan parameter id yang diambil dari widget.produk!.id. Fungsi ini melakukan request DELETE ke endpoint /produk/{id} dan kembali menginterpretasikan field status dari response JSON sebagai boolean keberhasilan. Jika penghapusan berhasil, Navigator.of(context).push dipanggil untuk kembali menampilkan ProdukPage sehingga daftar produk terpampang tanpa item yang telah dihapus. Jika terjadi error selama proses penghapusan, misalnya server mengembalikan status gagal atau koneksi bermasalah, maka aplikasi akan menampilkan WarningDialog dengan pesan “Hapus gagal, silahkan coba lagi”.

Seluruh operasi CRUD tersebut bergantung pada kelas ProdukBloc sebagai lapisan penghubung antara UI dan REST API. Fungsi getProduks() bertugas mengambil daftar produk, addProduk() dipakai untuk menyimpan produk baru, updateProduk() untuk mengubah data produk yang sudah ada, dan deleteProduk() untuk menghapus produk berdasarkan ID. Setiap fungsi menggunakan helper Api yang membungkus pemanggilan http.get, http.post, http.put, dan http.delete sekaligus menangani error berdasarkan kode status HTTP. Di sisi lain, kelas ApiUrl mengelola semua URL endpoint yang digunakan aplikasi sehingga jika alamat server berubah, pengembang cukup mengubah satu tempat saja. Dengan kombinasi antara ProdukPage, ProdukForm, ProdukDetail, ProdukBloc, serta helper Api dan ApiUrl, alur CRUD pada modul produk berjalan lengkap dan terstruktur: pengguna bisa melihat daftar produk, menambahkan produk baru, mengedit produk yang sudah ada, serta menghapus produk yang tidak diperlukan lagi, semuanya dengan feedback berupa dialog sukses atau gagal yang konsisten di seluruh aplikasi.

<img width="1579" height="877" alt="image" src="https://github.com/user-attachments/assets/3c386d11-8078-4846-9cc4-fcd15bcb0e0f" />

Selain fungsi tambah, edit, dan melihat produk, ProdukPage juga menyediakan menu Logout pada drawer. Ketika menu ini ditekan, drawer ditutup lebih dahulu, lalu aplikasi mengembalikan pengguna ke LoginPage menggunakan Navigator.pushAndRemoveUntil, yang artinya seluruh halaman sebelumnya benar-benar dihapus dari history. Dengan demikian, pengguna tidak bisa kembali ke ProdukPage dengan menekan tombol back setelah logout. Ini merupakan salah satu praktik standar keamanan dalam aplikasi autentikasi.

Secara keseluruhan, hubungan antarhalaman aplikasi Tokokita mengikuti alur yang logis dan terstruktur. Aplikasi dimulai dari LoginPage, kemudian mengalir ke ProdukPage setelah autentikasi berhasil. Dari ProdukPage, pengguna dapat mengakses ProdukForm untuk menambah produk baru atau melalui ProdukDetail untuk mengedit produk yang sudah ada. Pengguna juga dapat kembali ke halaman login melalui fitur logout. Melalui struktur tersebut, aplikasi berhasil membangun alur CRUD produk lengkap yang elegan dan mudah dipahami. Model data digunakan secara konsisten untuk mengelola informasi produk, login, dan registrasi. Navigasi antarhalaman menggunakan berbagai jenis Navigator (push, pushReplacement, pushAndRemoveUntil) untuk memastikan kontrol penuh terhadap perpindahan halaman dan keamanan alur aplikasi. Semua ini menjadikan aplikasi Tokokita sebagai contoh implementasi Flutter multihalaman yang baik, terstruktur, aman, dan mudah dikembangkan menjadi aplikasi toko online yang sesungguhnya.

<img width="678" height="892" alt="image" src="https://github.com/user-attachments/assets/67f1c712-f2aa-45fc-8033-d5f73f33ab64" />

<img width="679" height="895" alt="image" src="https://github.com/user-attachments/assets/82a6155b-6afe-4fc5-986f-3171ba50102b" />

<img width="677" height="889" alt="image" src="https://github.com/user-attachments/assets/2004610b-d30c-4def-a099-bc4fab27e31a" />

<img width="677" height="886" alt="image" src="https://github.com/user-attachments/assets/63aedb7d-e058-4ee5-9c01-20fa421d87d1" />

<img width="676" height="883" alt="image" src="https://github.com/user-attachments/assets/781d8396-bdf5-4e40-99e5-c68790251f2a" />

<img width="665" height="889" alt="image" src="https://github.com/user-attachments/assets/acf856df-2041-43f7-8117-4145dba6a179" />



